// Copyright (c) 2014 Nathan Martz

// Unity does not (currently) respect enabled property
// or the layer property for all renderable objects, esp
// when there are multiple cameras in the scene. An alternative,
// is to use Layers and a culling mask, but those don't work
// universally either. Current behavior (in 4.3) is:
// * Mesh can cull with layer or enabled, but enabled only works on first camera.
// * Light only works with enabled, layer seems to still have full costs.
// * Terrain only works with layer, enabled seems to have no effect unless set earlier than pre-cull.

// For now, only layer cull Terrain, as we don't properly handle the whole-object
// implications of layer culling.
//#define LAYER_CULL_RENDERERS
//#define LAYER_CULL_LIGHTS
#define LAYER_CULL_TERRAIN

using UnityEngine;
using System.Collections.Generic;

[ExecuteInEditMode]
[RequireComponent(typeof(SECTR_Member))]
/// \ingroup Vis
/// Culler is the complement to SECTR_CullingCamera, taking the culling frustum data
/// from Camera and applying it to the objects in the sibling SECTR_Member.
///
/// Culler operates as a kind of "overlay" on a Member. The Member
/// keeps track of all of the children and their bounds, which the Culler then
/// tests against clipped frustums and other culling data generated by Camera.
/// 
/// In SECTR Vis, all objects are "invisible" until they are intersected with a
/// (clipped) camera frustum. Once intersected with a single frustum, they are visible
/// for that camera, regardless of which other portals can or cannot see them.
[AddComponentMenu("SECTR/Vis/SECTR Culler")]
public class SECTR_Culler : MonoBehaviour
{
	#region Private Members
	#if LAYER_CULL_MESH || LAYER_CULL_LIGHT || LAYER_CULL_TERRAIN
	private struct HiddenObject
	{
		public HiddenObject(SECTR_Member.Child child)
		{
			this.child = child;
			originalLayer = child.gameObject.layer;
		}

		public SECTR_Member.Child child;
		public int originalLayer;
	}
	#endif

	// Dicts for keeping track of which objects are definitely visible.
	private Dictionary<Renderer, Renderer> visibleRenderers = new Dictionary<Renderer, Renderer>(16);
	private Dictionary<Light, Light> visibleLights = new Dictionary<Light, Light>(16);
	private Dictionary<Terrain, Terrain> visibleTerrains = new Dictionary<Terrain, Terrain>(2);
	// Lists for keeping track of the items we hid so that we can undo the hiding.
	#if LAYER_CULL_RENDERERS
	private List<HiddenObject> hiddenRenderers = new List<HiddenObject>(16);
	#else
	private List<Renderer> hiddenRenderers = new List<Renderer>(16);
	#endif
	#if LAYER_CULL_LIGHTS
	private List<HiddenObject> hiddenLights = new List<HiddenObject>(16);
	#else
	private List<Light> hiddenLights = new List<Light>(16);
	#endif
	#if LAYER_CULL_TERRAIN
	private List<HiddenObject> hiddenTerrains = new List<HiddenObject>(2);
	#else
	private List<Terrain> hiddenTerrains = new List<Terrain>(2);
	#endif
	// Cache the sibling SectorMember to save an expensive component lookup.
	private SECTR_Member cachedMember;

	// Useful stats
	private int renderersCulled = 0;
	private int lightsCulled = 0;
	private int terrainsCulled = 0;

	// Global list of cullers to accellerate iterating over the entire set.
	private static List<SECTR_Culler> allCullers = new List<SECTR_Culler>(128);
	#endregion

	#region Public Interface
	[SECTR_ToolTip("Determines if this SectorCuller should cull individual children, or cull all children based on the aggregate bounds.")]
	public bool CullEachChild = false;
	
	/// Quick accessor for all SectorCullers in the world.
	/// Much faster than FindObjectsOfType.
	public static List<SECTR_Culler> All
	{
		get { return allCullers; }
	}

	/// Return the number of renderers culled last frame.
	public int RenderersCulled { get { return renderersCulled; } }

	/// Return the number of lights culled last frame.
	public int LightsCulled { get { return lightsCulled; } }
	
	/// Return the number of lights culled last frame.
	public int TerrainsCulled { get { return terrainsCulled; } }

	/// Resets all stats. Useful for demos.
	public void ResetStats()
	{
		renderersCulled = 0;
		lightsCulled = 0;
		terrainsCulled = 0;
	}
	
	/// Applies the passed in frustum planes to the children of the SECTR_Member
	/// that is a sibling to this Culler. Objects that intersect the frustum
	/// are visible, everything else is not. Also returns by reference list of shadow
	/// casting lights to be used in the post graph walk shadow update. This function
	/// may be called many times per-frame, and an object is visible if it intersects with
	/// any of those frusta.
	/// <param name="cameraPos">The world space position of the culling camera.</param>
	/// <param name="frustumPlanes">Array of planes that define the culling frustum.</param>
	/// <param name="occluders">Array of planes that define the active occluders.</param>
	/// <param name="shadowLights">Reference to a list of shadow casting light sources that will be appended to.</param>
	/// <param name="baseMask">Bitmask for frustum checking. Should generally be 1 for each plane in the frustumPlanes.</param> 
	public void FrustumCull(Vector3 cameraPos, List<Plane> frustumPlanes, List<List<Plane>> occluders, ref List<SECTR_Member.Child> shadowLights, int baseMask)
	{
		int baseRenderMask = baseMask;
		int baseLightMask = baseMask;

		int parentRenderMask = 0;
		int parentLightMask = 0;

		// First, compute culling against gross bounds, for possible use as an early out.
		// In the culling below, these results will be used in lieu of per-child culling
		// for any SectorCullers with CullIndividualChildren set to false.
		bool memberRenderVisible = cachedMember.HasRenderBounds && SECTR_Geometry.FrustumIntersectsBounds(cachedMember.RenderBounds, frustumPlanes, baseRenderMask, out parentRenderMask);
		bool memberLightVisible = cachedMember.HasLightBounds && SECTR_Geometry.FrustumIntersectsBounds(cachedMember.LightBounds, frustumPlanes, baseLightMask, out parentLightMask);

		// Check the global bounds against any and all occluders
		int numOccluders = occluders.Count;
		for(int occluderIndex = 0; occluderIndex < numOccluders && (memberRenderVisible || memberLightVisible); ++occluderIndex)
		{
			List<Plane> occluder = occluders[occluderIndex];
			if(memberRenderVisible)
			{
				memberRenderVisible = !SECTR_Geometry.FrustumContainsBounds(cachedMember.RenderBounds, occluder);
			}
			if(memberLightVisible)
			{
				memberLightVisible = !SECTR_Geometry.FrustumContainsBounds(cachedMember.LightBounds, occluder);
			}
		}

		// If aggregate bounds are visible, process children
		if(memberRenderVisible)
		{
			int numRenderers = cachedMember.Renderers.Count;
			for(int rendererIndex = 0; rendererIndex < numRenderers; ++rendererIndex)
			{
				SECTR_Member.Child child = cachedMember.Renderers[rendererIndex];
				Renderer childRenderer = child.renderer;
				if(childRenderer && !visibleRenderers.ContainsKey(childRenderer) && childRenderer.enabled)
				{
					if(!CullEachChild || _IsVisible(child.rendererBounds, frustumPlanes, parentRenderMask, occluders))
					{
						visibleRenderers.Add(childRenderer, childRenderer);
					}
				}
			}
			int numTerrains = cachedMember.Terrains.Count;
			for(int terrainIndex = 0; terrainIndex < numTerrains; ++terrainIndex)
			{
				SECTR_Member.Child child = cachedMember.Terrains[terrainIndex];
				Terrain childTerrain = child.terrain;
				if(childTerrain && !visibleTerrains.ContainsKey(childTerrain) && childTerrain.enabled)
				{
					if(!CullEachChild || _IsVisible(child.terrainBounds, frustumPlanes, parentRenderMask, occluders))
					{
						visibleTerrains.Add(childTerrain, childTerrain);
					}
				}
			}
		}

		if(memberLightVisible)
		{
			int numLights = cachedMember.Lights.Count;
			for(int lightIndex = 0; lightIndex < numLights; ++lightIndex)
			{
				SECTR_Member.Child child = cachedMember.Lights[lightIndex];
				Light childLight = child.light;
				if(childLight && !visibleLights.ContainsKey(childLight) && childLight.enabled)
				{
					if(!CullEachChild || _IsVisible(child.lightBounds, frustumPlanes, parentRenderMask, occluders))
					{
						visibleLights.Add(childLight, childLight);
						if(child.shadowLight &&
						   Vector3.Distance(childLight.transform.position, cameraPos) - childLight.range <= QualitySettings.shadowDistance)
						{
							shadowLights.Add(child);
						}
					}
				}
			}
		}
	}
	
	/// Marks as visible any objects in the SectorCull that cast shadows,
	/// are overlapped by any of the shadow casting lights, and are
	/// compatible with the mask of the shadow casting source.
	/// <param name="shadowLights">List of shadow casting light sources.</param>
	public void ShadowCull(List<SECTR_Member.Child> shadowLights)
	{
		int numShadowLights = shadowLights.Count;
		int numShadowCasters = cachedMember.ShadowCasters.Count;

		// Unlike basic culling, the optimal flow of shadow testing depends
		// on the value of CullIndividualChildren. Knowing this value
		// allows smarter early outs and other computational savings.
		if(CullEachChild)
		{
			// If we're culling individual children, loop over renderers and then
			// over light sources. We can bail as soon as we find any light that overlaps,
			// and we can skip the global bounds as they don't help us.
			for(int shadowCasterIndex = 0; shadowCasterIndex < numShadowCasters; ++shadowCasterIndex)
			{
				SECTR_Member.Child shadowCasterChild = cachedMember.ShadowCasters[shadowCasterIndex];
				Renderer childRenderer = shadowCasterChild.renderer;
				if(childRenderer && !visibleRenderers.ContainsKey(childRenderer) && childRenderer.enabled)
				{
					for(int shadowLightIndex = 0; shadowLightIndex < numShadowLights; ++shadowLightIndex)
					{
						SECTR_Member.Child shadowLightChild = shadowLights[shadowLightIndex];
						Light shadowLight = shadowLightChild.light;
						if(((shadowLight.cullingMask & 1 << childRenderer.gameObject.layer) != 0))
						{
							if((shadowLight.type == LightType.Spot && shadowCasterChild.rendererBounds.Intersects(shadowLightChild.lightBounds)) ||
							   (shadowLight.type == LightType.Point && SECTR_Geometry.BoundsIntersectsSphere(shadowCasterChild.rendererBounds, shadowLight.transform.position, shadowLight.range)))
							{
								visibleRenderers.Add(childRenderer, childRenderer);
								break;
							}
						}
					}
				}
				Terrain childTerrain = shadowCasterChild.terrain;
				if(childTerrain && !visibleTerrains.ContainsKey(childTerrain) && childTerrain.enabled)
				{
					for(int shadowLightIndex = 0; shadowLightIndex < numShadowLights; ++shadowLightIndex)
					{
						SECTR_Member.Child shadowLightChild = shadowLights[shadowLightIndex];
						Light shadowLight = shadowLightChild.light;
						if(((shadowLight.cullingMask & 1 << childTerrain.gameObject.layer) != 0))
						{
							if((shadowLight.type == LightType.Spot && shadowCasterChild.terrainBounds.Intersects(shadowLightChild.lightBounds)) ||
							   (shadowLight.type == LightType.Point && SECTR_Geometry.BoundsIntersectsSphere(shadowCasterChild.terrainBounds, shadowLight.transform.position, shadowLight.range)))
							{
								visibleTerrains.Add(childTerrain, childTerrain);
								break;
							}
						}
					}
				}
			}
		}
		else
		{
			// If we're not culling individual children, loop over shadow casting lights
			// and then over individual members. However, we only have to do one
			// bounds test per-light, rather than per-child.
			for(int shadowLightIndex = 0; shadowLightIndex < numShadowLights; ++shadowLightIndex)
			{
				SECTR_Member.Child shadowLightChild = shadowLights[shadowLightIndex];
				Light shadowLight = shadowLightChild.light;

				// A child is affected by shadows if:
				// * The shadow bounds overlaps the member's render bounds (which includes terrain and renderers).
				// * They have a renderer or terrain that's enabled and not already visible.
				// * They cast dynamic shadows (computed in Child constructur)
				// * Their mask matches the light's mask.
				bool memberShadowed = shadowLight.type == LightType.Spot ? cachedMember.RenderBounds.Intersects(shadowLightChild.lightBounds) :
									  SECTR_Geometry.BoundsIntersectsSphere(cachedMember.RenderBounds, shadowLight.transform.position, shadowLight.range);
				if(memberShadowed)
				{
					int cullingMask = shadowLight.cullingMask;
					for(int shadowCasterIndex = 0; shadowCasterIndex < numShadowCasters; ++shadowCasterIndex)
					{
						SECTR_Member.Child shadowCasterChild = cachedMember.ShadowCasters[shadowCasterIndex]; 
						Renderer childRenderer = shadowCasterChild.renderer;
						Terrain childTerrain = shadowCasterChild.terrain;
						if(childRenderer && childTerrain)
						{
							// If a Child has both a renderer and a terrain, they share a game object, so use either.
							if((cullingMask & 1 << childRenderer.gameObject.layer) != 0)
							{
								if(!visibleRenderers.ContainsKey(childRenderer) && childRenderer.enabled)
								{
									visibleRenderers.Add(childRenderer, childRenderer);
								}
								if(!visibleTerrains.ContainsKey(childTerrain) && childTerrain.enabled)
								{
									visibleTerrains.Add(childTerrain, childTerrain);
								}
							}
						}
						else if(childRenderer && !visibleRenderers.ContainsKey(childRenderer) && childRenderer.enabled &&
						        (cullingMask & 1 << childRenderer.gameObject.layer) != 0)
						{
							visibleRenderers.Add(childRenderer, childRenderer);
						}
						else if(childTerrain && !visibleTerrains.ContainsKey(childTerrain) && childTerrain.enabled &&
						        (cullingMask & 1 << childTerrain.gameObject.layer) != 0)
						{
							visibleTerrains.Add(childTerrain, childTerrain);
						}
					}
				}
			}
		}
	}
	
	/// Use the visibility information computed in the previous culling steps to actually
	/// hide (i.e. enabled = false) renderers and lights affected by this Culler.
	public void ApplyCulling(int invisibleLayer)
	{
		// Save some resize malloc overhead by pre-sizing the containers.
		hiddenRenderers.Capacity = Mathf.Max(cachedMember.Renderers.Count - visibleRenderers.Count, hiddenRenderers.Capacity);
		hiddenLights.Capacity = Mathf.Max(cachedMember.Lights.Count - visibleLights.Count, hiddenLights.Capacity);
		hiddenTerrains.Capacity = Mathf.Max(cachedMember.Terrains.Count - visibleTerrains.Count, hiddenTerrains.Capacity);

		// Loop over all of the children of the sibling SectorMember.
		// Anything that's not in a visible list is, by definition, invisible.
		int numChildren = cachedMember.Children.Count;
		for(int childIndex = 0; childIndex < numChildren; ++childIndex)
		{
			SECTR_Member.Child child = cachedMember.Children[childIndex];
			Renderer childRenderer = child.renderer;
			if(childRenderer && !visibleRenderers.ContainsKey(childRenderer) && childRenderer.enabled)
			{
				#if LAYER_CULL_RENDERERS
				hiddenRenderers.Add(new HiddenObject(child));
				child.gameObject.layer = invisibleLayer;
				#else
				hiddenRenderers.Add(childRenderer);
				childRenderer.enabled = false;
				#endif
			}
			Light childLight = child.light;
			if(childLight && !visibleLights.ContainsKey(childLight) && childLight.enabled)
			{
				#if LAYER_CULL_LIGHTS
				hiddenLights.Add(new HiddenObject(child));
				child.gameObject.layer = invisibleLayer;
				#else
				hiddenLights.Add(childLight);
				childLight.enabled = false; 
				#endif
			}
			Terrain childTerrain = child.terrain;
			if(childTerrain && !visibleTerrains.ContainsKey(childTerrain) && childTerrain.enabled)
			{
				#if LAYER_CULL_TERRAIN
				hiddenTerrains.Add(new HiddenObject(child));
				child.gameObject.layer = invisibleLayer;
				#else
				hiddenTerrains.Add(childTerrain);
				childTerrain.enabled = false;
				#endif
			}
		}
	}
	
	/// Reverses the effects of ApplyCulling.
	public void UndoCulling()
	{
		// Reveal anything hidden and reset book keeping datastructures.
		int numRenderers = hiddenRenderers.Count;
		for(int renderIndex = 0; renderIndex < numRenderers; ++renderIndex)
		{
			#if LAYER_CULL_RENDERERS
			HiddenObject hiddenObject = hiddenRenderers[renderIndex];
			hiddenObject.child.gameObject.layer = hiddenObject.originalLayer;
			#else
			hiddenRenderers[renderIndex].enabled = true;
			#endif
		}
		hiddenRenderers.Clear();
		visibleRenderers.Clear();

		int numLights = hiddenLights.Count;
		for(int lightIndex = 0; lightIndex < numLights; ++lightIndex)
		{
			#if LAYER_CULL_LIGHTS
			HiddenObject hiddenObject = hiddenLights[lightIndex];
			hiddenObject.child.gameObject.layer = hiddenObject.originalLayer;
			#else
			hiddenLights[lightIndex].enabled = true;
			#endif
		}
		hiddenLights.Clear();
		visibleLights.Clear();

		int numTerrains = hiddenTerrains.Count;
		for(int terrainIndex = 0; terrainIndex < numTerrains; ++terrainIndex)
		{
			#if LAYER_CULL_TERRAIN
			HiddenObject hiddenObject = hiddenTerrains[terrainIndex];
			hiddenObject.child.gameObject.layer = hiddenObject.originalLayer;
			#else
			hiddenTerrains[terrainIndex].enabled = true;
			#endif
		}
		hiddenTerrains.Clear();
		visibleTerrains.Clear();

		renderersCulled = numRenderers;
		lightsCulled = numLights;
		terrainsCulled = numTerrains;
	}
	#endregion

	#region Unity Interface
	void OnEnable()
	{
		cachedMember = GetComponent<SECTR_Member>();
		allCullers.Add(this);
	}

	void OnDisable()
	{
		allCullers.Remove(this);
	}
	#endregion

	#region Private Methods
	bool _IsVisible(Bounds childBounds, List<Plane> frustumPlanes, int parentMask, List<List<Plane>> occluders)
	{
		int childOutMask;
		if(SECTR_Geometry.FrustumIntersectsBounds(childBounds, frustumPlanes, parentMask, out childOutMask))
		{
			int numOccluders = occluders.Count;
			for(int occluderIndex = 0; occluderIndex < numOccluders; ++occluderIndex)
			{
				if(SECTR_Geometry.FrustumContainsBounds(childBounds, occluders[occluderIndex]))
				{
					return false;
				}
			}
			return true;
		}
		return false;
	}
	#endregion
}
